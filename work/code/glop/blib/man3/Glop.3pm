.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glop 3"
.TH Glop 3 "2005-05-22" "perl v5.8.1" "User Contributed Perl Documentation"
\&\s-1BEGIN\s0 {
    *Glop::GLSpace:: = \e%SDL::OpenGL::;
}
.PP
package Glop;
.PP
use Glop::Floater;
use Glop::Kernel;
use Glop::Role;
use Glop::Draw;
use Glop::DisplayList;
use Glop::TransientQueue;
use Glop::Transient;
use Glop::Input;
use Glop::Actor;
use Glop::Agent;
use Glop::Texture;
use Glop::Physics;
.PP
our \f(CW$KERNEL\fR ||= Glop::Kernel\->new;
\&\f(CW$KERNEL\fR\->new_state;
.PP
sub init {
    my \f(CW$package\fR = shift;
.PP
.Vb 1
\&    my %opt = process_options @_;
.Ve
.PP
.Vb 3
\&    my %sdlinit = map { $_, $opt{$_} } 
\&                  grep { exists $opt{$_} }
\&                  qw{ -title -icon_title -icon -resizable };
.Ve
.PP
.Vb 2
\&    $sdlinit{-width} = $opt{-pixwidth} || 1024;
\&    $sdlinit{-height} = $opt{-pixheight} || 768;
.Ve
.PP
.Vb 5
\&    my $olderr;
\&    if ($opt{-quiet} || 1) { # XXX
\&        open $olderr, '>&', \e*STDERR;
\&        open STDERR, '>', undef;
\&    }
.Ve
.PP
.Vb 4
\&    $APP = SDL::App->new(
\&                %sdlinit,
\&               -flags => SDL_OPENGL | ($opt{-fullscreen} ? SDL_FULLSCREEN : 0),
\&           );
.Ve
.PP
.Vb 3
\&    if ($opt{-quiet} || 1) { # XXX
\&        open STDERR, '>&', $olderr;
\&    }
.Ve
.PP
.Vb 1
\&    $SORT = $opt{-sort};
.Ve
.PP
.Vb 2
\&    $opt{-view} ||= [ -1, -1, 1, 1 ];  # default to the biunit square
\&    view(@{$opt{-view}});
.Ve
.PP
.Vb 1
\&    package Glop::GLSpace;
.Ve
.PP
.Vb 2
\&    glEnable(GL_DEPTH_TEST);
\&    glDepthFunc(GL_LEQUAL);
.Ve
.PP
.Vb 2
\&    package Glop;
\&}
.Ve
.PP
sub view {
    package Glop::GLSpace;
    my \f(CW@view\fR = \f(CW@_\fR;
    glMatrixMode(\s-1GL_PROJECTION\s0);
        \fIglLoadIdentity()\fR;
        if (@view == 4) { # 2D
            gluOrtho2D(@view[0,2,1,3]);
        }
        elsif (@view == 2 || \f(CW@view\fR == 3) { # 3D
            my ($eye, \f(CW$center\fR, \f(CW$up\fR) = map { v(@$_) } \f(CW@view\fR;
            if ($up == v()) {
                \f(CW$up\fR = ($center \- \f(CW$eye\fR) x v(1,0,0);
                if ($up == 0) {  # ugh
                    \f(CW$up\fR = ($center \- \f(CW$eye\fR) x v(0,1,0);
                }
            }
            gluPerspective(45, 4/3, 0.1, 100);
            gluLookAt(@$eye, @$center, @$up);
        }
        else {
            Carp::croak(\*(L"Invalid view parameter\*(R");
        }
    glMatrixMode(\s-1GL_MODELVIEW\s0);
}
.PP
\&\s-1INIT\s0 { _\|_PACKAGE_\|_\->init(@$init_args) if \f(CW$init_args\fR; }
.PP
sub v {
    ODE::Vector\->new(@_);
}
.PP
sub preserve(&) {
    \fIGlop::GLSpace::glPushMatrix()\fR;
    my \f(CW$ret\fR = \f(CW$_\fR[0]\->();
    \fIGlop::GLSpace::glPopMatrix()\fR;
    \f(CW$ret\fR;
}
.PP
sub drawing(&) {
    my \f(CW$ret\fR = Glop::DisplayList\->new\->record;
    \f(CW$_\fR[0]\->();
    \f(CW$ret\fR\->done;
}
.PP
sub zorder($) {
    my ($z) = \f(CW@_\fR;
    Glop::GLSpace::glTranslate(0, 0, \f(CW$z\fR);
}
.PP
{
    my \f(CW%invar\fR;
    sub invar(&) {
        my \f(CW$id\fR = join $;, caller;
        if ($invar{$id}) {
            \f(CW$invar\fR{$id}\->draw;
        }
        else {
            package Glop::GLSpace;
            my \f(CW$list\fR = Glop::DisplayList\->new\->record('execute');
            \f(CW$_\fR[0]\->($list);
            \f(CW$list\fR\->done;
            \f(CW$invar\fR{$id} = \f(CW$list\fR;
        }       
        \f(CW$invar\fR{$id};
    }
}
.PP
sub within_box {
    my ($v, \f(CW$ll\fR, \f(CW$ur\fR) = \f(CW@_\fR;
    \f(CW$ll\fR\->x <= \f(CW$v\fR\->x && \f(CW$v\fR\->x <= \f(CW$ur\fR\->x &&
    \f(CW$ll\fR\->y <= \f(CW$v\fR\->y && \f(CW$v\fR\->y <= \f(CW$ur\fR\->y &&
    \f(CW$ll\fR\->z <= \f(CW$v\fR\->z && \f(CW$v\fR\->z <= \f(CW$ur\fR\->z;
}
.PP
package ODE::Vector;
# Amend ODE::Vector's interface
.PP
use \s-1POSIX\s0 qw{floor};
.PP
sub quantize {
    my ($self, \f(CW$q\fR) = \f(CW@_\fR;
    \f(CW$q\fR ||= 1;
    if (ref \f(CW$q\fR) {
        ODE::Vector\->new(
            ($q\->x ? floor($self\->x / \f(CW$q\fR\->x) * \f(CW$q\fR\->x : \f(CW$self\fR\->x),
            ($q\->y ? floor($self\->y / \f(CW$q\fR\->y) * \f(CW$q\fR\->y : \f(CW$self\fR\->y),
            ($q\->z ? floor($self\->z / \f(CW$q\fR\->z) * \f(CW$q\fR\->z : \f(CW$self\fR\->z),
        );
    }
    else {
        ODE::Vector\->new(
            floor($self\->x / \f(CW$q\fR) * \f(CW$q\fR,
            floor($self\->y / \f(CW$q\fR) * \f(CW$q\fR,
            floor($self\->z / \f(CW$q\fR) * \f(CW$q\fR,
        );
    }
}
.PP
1;
.SH "NAME"
Glop \- Game Language Of Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Glop qw{ :all };
.Ve
.PP
.Vb 3
\&    my $position = v(1,2);       # Create a 2D point/vector
\&    my $normal = v(1,2,3);       # Create a 3D point/vector
\&    # See ODE::Vector for the rest of this interface
.Ve
.PP
.Vb 4
\&    glBegin(GL_LINES);           # use OpenGL commands
\&        glVertex(@$position);    # use vectors as arrayrefs 
\&        glVertex(@$normal);
\&    glEnd();
.Ve
.PP
.Vb 5
\&    preserve {                   # surround in glPush/PopMatrix
\&        glTranslate(1,0,0);
\&        # ...
\&    };
\&    # translated back
.Ve
.PP
.Vb 4
\&    my $list = drawing {         # create a display list
\&        # OpenGL commands ...
\&    };
\&    $list->draw;                 # draw the list
.Ve
.PP
.Vb 2
\&    # Check that (0,0) is in the box from (-1,-1) to (1,1)
\&    within_box(v(0,0), v(-1,-1), v(1,1)) or die;
.Ve
.PP
.Vb 2
\&    # Use it in 3D
\&    within_box(v(0,1,1), v(0,0,0), v(2,2,2)) or die;
.Ve

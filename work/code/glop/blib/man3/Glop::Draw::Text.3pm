.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glop::Draw::Text 3"
.TH Glop::Draw::Text 3 "2005-05-22" "perl v5.8.1" "User Contributed Perl Documentation"
.SH "TITLE"
.IX Header "TITLE"
Glop::Draw::Text \- Draw text
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    Glop::Draw->Text("Hello, World!");
.Ve
.PP
.Vb 5
\&    Glop::Draw->Text(
\&        "Hello, World!",
\&        -font => 'foo.ttf',  # specify a path
\&        -size => 72,         # specify a rendering size (not screen size)
\&    );
.Ve
.PP
.Vb 3
\&    use Glop::Draw::Text;   # you'll have to manually use it for this form
\&    # create a text object in order to avoid re-rendering each time
\&    my $text = Glop::Draw::Text->new("Hello, World!", -size => 72);
.Ve
.PP
.Vb 1
\&    $text->draw;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Draws text on the screen, with the lower-left corner at the origin.  The
height is always 1, and the width is scaled based on the width of the
text.  Use the OpenGL matrix manipulation functions to get different
behavior as usual.
.Sh "Options"
.IX Subsection "Options"
When using the canonical drawing syntax (\f(CW\*(C`Glop::Draw\-\*(C'\fRText>), or when creating
a new text object, this takes two options:
.IP "\-font" 4
.IX Item "-font"
Sets the font.  This can be a standard font ('aircut' is the only one currently
supported) or a path to a \f(CW\*(C`ttf\*(C'\fR font.
.IP "\-size" 4
.IX Item "-size"
Sets the \fIrendering\fR size.  That is, higher numbers don't make what is drawn
bigger, but rather better\-looking.  The default is 24.
.Sh "Methods"
.IX Subsection "Methods"
If you create a text object with:
.PP
.Vb 1
\&    my $text = Glop::Draw::Text->new("Foo Bar");
.Ve
.PP
Then \f(CW$text\fR has the following methods:
.IP "draw" 4
.IX Item "draw"
Draw the text on the screen as described above.
.IP "width" 4
.IX Item "width"
Returns the width of the text in world units (not pixels).
.IP "height" 4
.IX Item "height"
Returns the height of the text in world units.  This is always 1.
.Sh "Efficiency Considerations"
.IX Subsection "Efficiency Considerations"
When you call \f(CW\*(C`Glop::Draw\-\*(C'\fRText>, the following procedure is followed:
.IP "1) A new pixel buffer (SDL::Surface) is created." 4
.IX Item "1) A new pixel buffer (SDL::Surface) is created."
.PD 0
.IP "2) A new font object (SDL::TTFont) is created." 4
.IX Item "2) A new font object (SDL::TTFont) is created."
.IP "3) The text is drawn onto the pixel buffer using the font." 4
.IX Item "3) The text is drawn onto the pixel buffer using the font."
.IP "4) That pixel buffer is imported onto your graphics card as a texture." 4
.IX Item "4) That pixel buffer is imported onto your graphics card as a texture."
.IP "5) The buffer and font objects are destroyed." 4
.IX Item "5) The buffer and font objects are destroyed."
.IP "6) A square with the texture applied is drawn." 4
.IX Item "6) A square with the texture applied is drawn."
.IP "7) The texture is freed." 4
.IX Item "7) The texture is freed."
.PD
.PP
When you call \f(CW\*(C`Glop::Draw::Text\-\*(C'\fRnew>, steps 1\-5 are executed.  So, if you're
going to be drawing the text for more than one frame, it is recommended that you
create an object instead of using the \*(L"easy\*(R" form.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glop

=head1 TITLE

Perl 6 Theories - Grand unified object model

=head1 SYNOPSIS

    # theory representing a total order
    theory Ordered{::T} {
        multi infix:«<=» (T $x, T $y --> Bool) {...}
        multi infix:«>=» (T $x, T $y --> Bool) { $y <= $x }
        multi infix:«>»  (T $x, T $y --> Bool) { not $x <= $y }
        ...
    }

    # a cons list data type
    union MyList[::T] (
        MyNil,
        MyCons(T $.head, MyList[T] $.tail),
    );
    
    # Lists of ordered things are lexographically ordered
    # (read <= as "if" rather than "less than or equal to")
    model Ordered{MyList[::T]} <= Ordered{::T} {
        multi infix:«<=» (MyNil,  _)     { true }
        multi infix:«<=» (MyCons, MyNil) { false }
        multi infix:«<=» (MyCons ($h1, $t1), MyCons ($h2, $t2)) {
            when $h1 <= $h2 { true }
            when $h2 >  $h1 { false }
            default         { $t1 <= $t2 }
        }

        # the theory automatically fills in <, >, >=, ==, etc.
    }

=head1 DESCRIPTION

*** INTRO ***

=head2 Tuples

The first piece of machinery we need is the tuple.  The tuple underlies
all of the semantics here, but you never really see it.  Perl 6's tuple
is much richer than tuples of other languages; in short, it is an object
representing a parameter list.

The tuple has three parts: positional, named, and block, any of which can
be empty.  It is constructed using the comma.

    my $tuple = (1, :foo(2), 3, 4):{ $_ + 1 };

This tuple has three positionals, C<1,3,4>;  one named, C<< foo => 2 >>;
and one block, C<{ $_ }>.  The block parameters are specified as adverbs
on the tuple as a whole.  If you want a block inside a positional, just
put one there.  If you want a pair inside a positional, enclose it in
parentheses (that is, named elements are I<lexically> determined; in the
tuple (1,$x), $x will always be positional, whether or not it contains a
pair):

    my $tuple = ({ $_ + 1 }, (foo => 2));  # two positionals

Unlike in most other languages, a single-argument tuple is not the same
as a value.  To create a single-argument tuple (which ought to be an
uncommon thing), use a null comma at the end:

    my $tuple = ("foo",);                  # a tuple with one positional

Tuples, like lists, may be flattened into other tuples:

    my $a = (1,2,3);    # a tuple with positionals 1,2,3
    my $b = (0,*$a,4);  # a tuple with positionals 0,1,2,3,4

As a special case, function application will automatically (lexically)
tuplize a single argument:

    foo($x);            # equivalent to foo($x,)

And therefore, you can think of all functions as taking only a single
argument: the tuple of the argument list.  This will be important later.

Lists and tuples should interact in a reasonable way so that you can
pretend that they're the same thing (but in a strongly typed dialect,
they are quite different).  *** HANDWAVE ***

Since a tuple is essentially an argument list, a tuple pattern is
essentially a parameter list.  The meaning of the slurpy scalar C<*$x>
has changed.  Now it is just like a slurpy list, except that it gathers
the rest of the signature into a tuple C<$x> instead of a list.  To
facilitate the technique that the slurpy scalar was originally
introduced for, we can use this:

    sub first (*[ $x, *@xs ]) { $x }

The upshot is that you can easily delegate an arbitrary argument list to
another function:

    sub foo (*$args) { bar(*$args) }   # call bar with whatever args foo
                                       # was called with

Tuples also have a pattern constructor, comma, for use in signatures and
bindings.  So you can say:

    multi snd (($x, $y)) { $y }

C<snd> takes only one argument (no, I mean that in the usual sense, not
the every-function-takes-exactly-one-argument sense), where that
argument is a two-tuple, and it extracts the second element.  Now, what
the heck is a pattern constructor?

=head2 Pattern Constructors

Before we get to exactly what a pattern constructor is, let's define
what a pattern is.  A pattern is a thing that can extract
"subinformation" out of an object as it's being bound.  It appears in
argument lists like so:

    rule parameter { <type> <zone> <parameter_name>  <pattern>? 
                   |        <zone> <parameter_name>? <pattern>? }

There are several patterns with special syntax: square brackets for
matching inside arrays, curly brackets for matching out of hashes, bare
parentheses for matching a tuple, all numeric and string literals (for
matching themselves under C<eqv>), perhaps among others.  These either
require a set of syntactic categories (like C<< pattern:term:<...> >>)
or a straight-up grammar munge.  

The patterns that are easy to define are the I<normal patterns>.  These
are given by the rule:

    rule normal_pattern { <pattern_name> <tuple_pattern>? }

(If the C<tuple_pattern> is omitted, the empty tuple C<()> is assumed)

So you'll have things like:

    multi traverse (Leaf ($v), *&code) { &code($v) }
    multi traverse (Branch ($l, $r), *&code) { 
        traverse($l):&code;
        traverse($r):&code;
    }

Where that first line could have also been either of:

    multi traverse ($leaf Leaf ($v), *&code)   {...}
    multi traverse (Tree _ Leaf ($v), *&code)  {...}

But those don't add anything to the readability in this case.

How does one define a normal pattern constructor?  By placing names into
the C<pattern:> grammatical category.  A normal pattern constructor
takes a type and returns a tuple, which is then unified against the
given tuple pattern.

For instance, I could define an identity pattern that would just return
the one-tuple of the object:

    sub pattern:<Id> ($obj) { ($obj,) }

Or the typed version:

    sub pattern:<Id> (::T $obj --> (::T,)) { ($obj,) }

You could use this pattern to give more than one name to an argument:

    sub mul3 ($x Id ($y Id ($z))) { $x + $y + $z }

Other than that, it's not useful, of course.  But that goes to show that
if the pattern constructors are typed, they imply those type constraints
on the corresponding argument:

    sub pattern:<Leaf> (Tree $t --> (Any,)) {...}

    multi traverse (Tree _ Leaf ($value)) {...}

The C<Tree> in the second declaration is redundant; the C<Leaf> pattern
already implies it.

=head2 Classes and Roles

There are two ways to create a concrete type, otherwise known as a
class.  One is with the C<class> declarator, the other is the C<union>
declarator (which we'll get to in a bit).  A class defined by its
I<instance data> (or attributes) and its I<interface> (or methods).

    class Account {
        has $.balance;     # instance data and interface
        has $.name;        # instance data and interface
        has $._password;   # instance data
        
        method withdrawl ($amount, $password) {  # interface
            # ...
        }
    }

This definition does two things: it defines the package C<Account> with
a C<new> constructor (which puts together the instance data), and it
defines the role C<Account> that contains pretty much the body of the
class, specifying its interface with default implementations (when you
say C<has $.balance>, you are specifying the interface method C<balance>
with a default implementation of object state).  Whenever you say
C<Account> in type position (after a C<my> or in a signature), you are
referring to this role.  Whenever you say C<Account> elsewhere, you are
referring to the package.

To subclass a class, you say that a new class C<specializes> the old
one:

    class CreditAccount {
        specializes Account;
        
        method withdrawl ($amount, $password) {
            # try to borrow some money
        }
    }

Of course, you are specializing the role C<Account>, not the class.  In
fact, the class doesn't exist at all; it is just a notation to define
the package, concrete type, and role all at once.  You can also use the
dwimmical extender C<does> instead of C<specializes>.

Since C<CreditAccount> specializes C<Account>, a C<CreditAccount> can be
used anywhere an C<Account> can.  This is a consequence of the fact that
it is a role, not that you specialized it.  More on that later when we
get to L<Theories>.

=head2 Unions and Factories

Perl 6 supports union types (also called case types or algebraic data
types). Union types are to factores what classes are to roles (more on
that later).  To demonstrate the syntax, let's define a simple binary
tree:

    union Tree (
        Leaf($value),
        Branch(Tree $left, Tree $right),
    );

The case types (C<Leaf> and C<Branch>) are defined as a I<constructor
name> followed by a tuple pattern; i.e. an argument list.  Like
C<class>, there is no such thing as the union C<Tree>; it is just a
notation to define a bunch of related things:

It defines the packages C<Tree>, C<Tree::Leaf>, and C<Tree::Branch>.  It
defines (so far empty) roles C<Tree::Leaf> and C<Tree::Branch>, and the
I<factory> C<Tree>:

    # automatically defined
    factory Tree {
        producer Leaf ($value) {...}
        producer Branch (Tree $left, Tree $right) {...}
    }

A factory is the dual of a role: it defines a bunch of functions that
I<return> C<Tree>s (where roles define functions that I<accept> trees).
C<producer> is the corresponding dual to C<method> (it returns the thing
in question).  We'll see why there's all this vocabulary later.

Unions can be parameterized over one or more types:

    union Tree[::T] (
        Leaf(T $value),
        Branch(Tree[T] $left, Tree[T] $right),
    );

And the return type of the constructor functions can be stated
explicitly to form a GADT:

    union AST[::] (    # :: is a siglet meaning "a type"
        Const(::T                          --> AST[::T]),
        Cond(AST[Bool], AST[::T], AST[::T] --> AST[::T]),
        Succ(AST[Int]                      --> AST[Int]),
        ...
    );

If the argument names to the constructors are given C<$.attribute> form,
then attribute accessors are defined on the type:

    union Tree (
        Leaf($.value),
        Branch(Tree $.left, Tree $.right),
    );
    Leaf(4).value;                         # 4
    Branch(Leaf(2), Leaf(3)).right.value;  # 3
    Leaf(4).left;   # method found but pattern match failed

=head2 Vocabulary

Here is a summary of the object-oriented vocabulary in Perl:

=over

=item * C<theory>

The big one in the types department.  Specifies a general algebra over
one or more types.

=item * C<role>

A I<covariant>, I<unary> theory, that is, a theory over a single type
where the functions defined within only take the type as a parameter,
never return it.

=item * C<factory>

A I<contravariant>, I<unary> theory, that is, a theory over a single
type where the functions defined within only return the type, never take
it as a parameter.

=item * C<class>

A notation that simultaneously defines a role, a concrete type, and a
package of the given name.

=item * C<union>

A notation that simultaneously defines a factory together with a
concrete type, a role, and a package for each case in the factory.

=item * C<multi>

The big one in the functions department.  Specifies a
multiply-implemented function dispatched based on the involved types.

=item * C<method>

Goes with roles.  Defines a multi that takes the topic type as its first
parameter.

=item * C<producer>

Goes with factories.  Defines a multi that returns the topic type.

=back

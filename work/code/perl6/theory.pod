=head1 TITLE

Perl 6 Theories - Grand unified object model

=head1 SYNOPSIS

    # theory representing a total order
    theory Ordered{::T} {
        multi infix:«<=» (T $x, T $y --> Bool) {...}
        multi infix:«>=» (T $x, T $y --> Bool) { $y <= $x }
        multi infix:«>»  (T $x, T $y --> Bool) { not $x <= $y }
        ...
    }

    # a cons list data type
    union MyList[::T] (
        MyNil,
        MyCons(T $.head, MyList[T] $.tail),
    );
    
    # Lists of ordered things are lexographically ordered
    # (read <= as "if" rather than "less than or equal to")
    model Ordered{MyList[::T]} <= Ordered[::T] {
        multi infix:«<=» (MyNil,  _)     { true }
        multi infix:«<=» (MyCons, MyNil) { false }
        multi infix:«<=» (MyCons ($h1, $t1), MyCons ($h2, $t2)) {
            when $h1 <= $h2 { true }
            when $h2 >  $h1 { false }
            default         { $t1 <= $t2 }
        }

        # the theory automatically fills in <, >, >=, ==, etc.
    }

=head1 DESCRIPTION

*** INTRO ***

=head2 Tuples

The first piece of machinery we need is the tuple.  The tuple underlies
all of the semantics here, but you never really see it.  Perl 6's tuple
is much richer than tuples of other languages; in short, it is an object
representing a parameter list.

The tuple has four parts: positional, named, and block, any of which can
be empty.  It is constructed using the comma.

    my $tuple = (1, :foo(2), 3, 4):{ $_ + 1 };

This tuple has three positionals, C<1,3,4>;  one named, C<< foo => 2 >>;
and one block, C<{ $_ }>.  The block parameters are specified as adverbs
on the tuple as a whole.  If you want a block inside a positional, just
put one there.  If you want a pair inside a positional, enclose it in
parentheses (that is, named elements are I<lexically> determined; in the
tuple (1,$x), $x will always be positional, whether or not it contains a
pair):

    my $tuple = ({ $_ + 1 }, (foo => 2));  # two positionals

Unlike in most other languages, a single-argument tuple is not the same
as a value.  To create a single-argument tuple (which ought to be an
uncommon thing), use a null comma at the end:

    my $tuple = ("foo",);                  # a tuple with one positional

Tuples, like lists, may be flattened into other tuples:

    my $a = (1,2,3);    # a tuple with positionals 1,2,3
    my $b = (0,*$a,4);  # a tuple with positionals 0,1,2,3,4

As a special case, function application will automatically (lexically)
tuplize a single argument:

    foo($x);            # equivalent to foo($x,)

And therefore, you can think of all functions as taking only a single
argument: the tuple of the argument list.  This will be important later.

Lists and tuples should interact in a reasonable way so that you can
pretend that they're the same thing (but in a strongly typed dialect,
they are quite different).  *** HANDWAVE ***

Since a tuple is essentially an argument list, a tuple pattern is
essentially a parameter list.  I propose one change to the meaning of a
parameter list term: C<*$x>, the slurpy scalar.  This is just like a
slurpy list, except that it gathers the rest of the signature into a
tuple C<$x> instead of a list.  To facilitate the technique that the
slurpy scalar was introduced for, we can use this:

    sub first (*[ $x, *@xs ]) { $x }

The upshot is that you can easily delegate an arbitrary argument list to
another function:

    sub foo (*$args) { bar(*$args) }   # call bar with whatever args foo
                                       # was called with

Tuples also have the pattern constructor, comma, for use in signatures
and bindings.  So you can say:

    multi snd (($x, $y)) { $y }

C<snd> takes only one argument (no, I mean it takes one argument that is
a one-tuple), where that argument is a two-tuple, and it extracts the
second element.  More on pattern constructors later.

=head2 Union Types

Perl 6 supports union types (also called case types or algebraic data
types). Union types are to factores what classes are to roles (more on
that later).  To demonstrate the syntax, let's define a simple binary
tree:

    union Tree (
        Leaf($value),
        Branch(Tree $left, Tree $right),
    );

The case types (C<Leaf> and C<Branch>) are defined as a I<constructor
name> followed by a tuple pattern; i.e. an argument list.  This
definition does many things at once:

=over

=item * 

Defines the types and packages C<Tree>, C<Tree::Leaf>, and
C<Tree::Branch>.

=item *

Defines the functions C<< &Leaf:($value --> Tree) >> and C<<
&Branch:($left, $right --> Tree) >> in the package C<Tree> and exports
them to the scope in which the union was defined.

=item *

Defines the pattern constructors C<Leaf> and C<Branch> in the package
C<Tree> and exports them to the scope in which the union was defined.
These pattern constructors both act on a single tuple pattern, like:

    sub foo (Branch($l, $r)) {...}

Or:

    sub foo ($node Branch($l, $r)) {...}

=back

Unions can be parameterized over one or more types:

    union Tree[::T] (
        Leaf(T $value),
        Branch(Tree[T] $left, Tree[T] $right),
    );

And the return type of the constructor functions can be stated
explicitly to form a GADT:

    union AST[::] (    # :: is a siglet meaning "a type"
        Const(::T                          --> AST[::T]),
        Cond(AST[Bool], AST[::T], AST[::T] --> AST[::T]),
        Succ(AST[Int]                      --> AST[Int]),
        ...
    );


